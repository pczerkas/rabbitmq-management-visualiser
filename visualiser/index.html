<html>

<head>
<title>RabbitMQ Topology Visualiser</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-min.js"></script>
<script type="text/javascript" src="octtree.js"></script>
<script type="text/javascript" src="physics.js"></script>
<script type="text/javascript" src="model.js"></script>
<script type="text/javascript">

var updatePeriod = 1000; // 1 second

var updateTimer = undefined;
var client = new XMLHttpRequest();
client.onreadystatechange = updateReady;

var configuration = undefined;

var tree = octtree.create(0, 10000, 0, 1000000, -0.5, 2);
var model = new Model();
var mousePos = vec3.create();
var mouseDown = false;
var mouseDragOffsetVec = undefined;
var highlight = "#ffffc0";
var selected = undefined;

function update() {
    client.open("GET", "/api/all");
    client.send();
};

function updateReady() {
    if (client.readyState == 4 && client.status == 200) {
        updateTimer = setTimeout("update();", updatePeriod);
        configuration = JSON.parse(client.responseText);
        model.rebuild(tree, configuration);
    }
};

exchange.postRender = draggable;
queue.postRender = draggable;

function draggable(elem, ctx) {
    var inPath = ctx.isPointInPath(mousePos[octtree.x], mousePos[octtree.y]); 
    if ((inPath && undefined == selected) || selected == elem) {
        ctx.fillStyle = highlight;
        ctx.fill();
        
        if (mouseDown) {
            selected = elem;
            if (undefined == mouseDragOffsetVec) {
                mouseDragOffsetVec = vec3.create(elem.pos);
                vec3.subtract(mouseDragOffsetVec, mousePos);
            }
            vec3.set(mousePos, elem.next_pos);
            vec3.add(elem.next_pos, mouseDragOffsetVec);
            elem.velocity = vec3.create();
            clamp(elem);
        } else if (!inPath) {
            selected = undefined;
            mouseDragOffsetVec = undefined;
        }
    } else {
        ctx.fillStyle = "white";
        ctx.fill();
    }  
};

window.requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
             window.setTimeout(callback, 1000/60);
           };
  })();

var ctx = undefined;
var canvas = undefined;

function mouseMove(e) {
    var x = 0;
    var y = 0;
    if (e.pageX || e.pageY) { 
        x = e.pageX;
        y = e.pageY;
    } else { 
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
    } 
    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;
    mousePos[octtree.x] = x;
    mousePos[octtree.y] = y;
};

function resizeCanvas() {
    if (undefined != canvas) {
        canvas.width = window.document.body.offsetWidth;
        canvas.height = window.document.body.offsetHeight;
        exchange.canvasResized(canvas);
        queue.canvasResized(canvas);
    }
};

function initCanvas(canvas) {
    resizeCanvas();
    canvas.onmousemove = mouseMove;
    canvas.onmousedown = function (e) {
        mouseDown = true;
        mouseDragOffsetVec = undefined;
    };
    canvas.onmouseup = function (e) {
        mouseDown = false;
        mouseDragOffsetVec = undefined;
        selected = undefined;
    };
    try {
        ctx = canvas.getContext("2d");
    } catch (e) {
    }
    if (!ctx) {
        alert("Could not initialise 2D canvas. Change browser?");
    }
}

var lastTime = 0;

function drawScene() {
    ctx.lineWidth = 1.0;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "black";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    var e;
    for (var i in model.exchanges) {
        exchange.render(model, model.exchanges[i], ctx);
    }
    for (var i in model.queues) {
        queue.render(model, model.queues[i], ctx);
    }
    for (var i in model.bindings.source) {
        var ary = model.bindings.source[i];
        for (var j = 0; j < ary.length; ++j) {
            binding.render(model, ary[j], ctx);
        }
    }
};

function clamp(elem) {
    if (elem.next_pos[octtree.x] < 1) {
        elem.next_pos[octtree.x] = 1
    };
    if (elem.next_pos[octtree.y] < 1) {
        elem.next_pos[octtree.y] = 1        
    }
    if (elem.next_pos[octtree.x] >= canvas.width) {
        elem.next_pos[octtree.x] = canvas.width - 1;
    };
    if (elem.next_pos[octtree.y] >= (canvas.height - 100)) {
        canvas.height += 100;
    }
};

var newton = new Newton();
var spring = new Spring();
spring.octtreeRadius = 500;
spring.equilibriumLength = 50;
spring.dampingFactor = 0.01;
spring.pull = false;
spring.push = true;

function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
        var elapsed = (timeNow - lastTime) / 10000;
        var e;
        for (var i in model.exchanges) {
            e = model.exchanges[i];
            if (undefined == selected || selected != e) {
                exchange.animate(elapsed, e);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        for (var i in model.queues) {
            e = model.queues[i];
            if (undefined == selected || selected != e) {
                queue.animate(elapsed, e);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        tree.update();
    }
    lastTime = timeNow;
};

function tick() {
    requestAnimFrame(tick);
    drawScene();
    animate();
};

function visualisationStart() {
    canvas = document.getElementById("topology-canvas");
    initCanvas(canvas);
    update();
    tick();
}

</script>
</head>
<body onload="visualisationStart();" onresize="resizeCanvas();">
    <canvas id="topology-canvas"></canvas>
</body>
</html>