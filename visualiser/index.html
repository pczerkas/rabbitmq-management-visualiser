<!DOCTYPE html>
<html>

<head>
<title>RabbitMQ Topology Visualiser</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-min.js"></script>
<script type="text/javascript" src="octtree.js"></script>
<script type="text/javascript" src="physics.js"></script>
<script type="text/javascript" src="model.js"></script>
<script type="text/javascript">

var updatePeriod = 1000; // 1 second

var updateTimer = undefined;
var client = new XMLHttpRequest();
client.onreadystatechange = updateReady;

var configuration = undefined;

var tree = octtree.create(0, 10000, 0, 1000000, -0.5, 2);
var model = new Model();
var mousePos = vec3.create();
var mouseDown = false;
var mouseDragOffsetVec = undefined;
var highlight = "#ffffc0";
var faded = "#b0b0b0";
var hoveringOver = undefined;
var dragging = undefined;

function update() {
    client.open("GET", "/api/all");
    client.send();
};

function updateReady() {
    if (client.readyState == 4 && client.status == 200) {
        updateTimer = setTimeout("update();", updatePeriod);
        configuration = JSON.parse(client.responseText);
        model.rebuild(tree, configuration);
    }
};

function draggable(ctx) {
    var inPath = ctx.isPointInPath(mousePos[octtree.x], mousePos[octtree.y]);
    if ((inPath && undefined == hoveringOver) || dragging == this || hoveringOver == this) {
        ctx.fillStyle = highlight;
        ctx.fill();

        hoveringOver = this;
        if (mouseDown) {
            dragging = this;
            if (undefined == mouseDragOffsetVec) {
                mouseDragOffsetVec = vec3.create(this.pos);
                vec3.subtract(mouseDragOffsetVec, mousePos);
            }
            vec3.set(mousePos, this.next_pos);
            vec3.add(this.next_pos, mouseDragOffsetVec);
            this.velocity = vec3.create();
            clamp(this);
        } else if (!inPath) {
            dragging = undefined;
            hoveringOver = undefined;
            mouseDragOffsetVec = undefined;
        }
    } else {
        ctx.fillStyle = "white";
        ctx.fill();
    }
    if (undefined != hoveringOver && hoveringOver != this) {
        ctx.strokeStyle = faded;
    }
};
Exchange.prototype.preStroke = draggable;
Queue.prototype.preStroke = draggable;
Binding.prototype.preStroke = function(source, destination, ctx) {
    if (undefined != hoveringOver) {
        if (hoveringOver == source) {
            ctx.strokeStyle = "#0000a0";
        } else if (hoveringOver == destination) {
            ctx.strokeStyle = "#00a000";
        } else {
            ctx.strokeStyle = faded;
        }
    }
};

var requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
             window.setTimeout(callback, 1000/60);
           };
  })();

var ctx = undefined;
var fontSize = 12;
Exchange.prototype.fontSize = fontSize;
Queue.prototype.fontSize = fontSize;
Binding.prototype.fontSize = fontSize;
var canvas = undefined;
var canvasLeft = 0;
var canvasTop = 0;
var scrollLeft = 0;
var scrollTop = 0;

function mouseMove(e) {
    var x = e.pageX;
    var y = e.pageY;
    x = (x - canvasLeft) + scrollLeft;
    y = (y - canvasTop) + scrollTop;
    mousePos[octtree.x] = x;
    mousePos[octtree.y] = y;
    document.getElementById("coords").innerHTML = "" + x + ", " + y;
};

function resizeCanvas() {
    if (undefined != canvas) {
        canvas.width = canvas.parentNode.offsetWidth;
        canvas.height = canvas.parentNode.offsetHeight;
        Exchange.prototype.canvasResized(canvas);
        Queue.prototype.canvasResized(canvas);
    }
};

function canvasScroll() {
    scrollLeft = 0;
    scrollTop = 0;
    var e = canvas.parentNode;
    while (undefined != e) {
        if (undefined != e.scrollLeft && undefined != e.scrollTop) {
            scrollLeft += e.scrollLeft;
            scrollTop += e.scrollTop;
        }
        e = e.parentNode;
    }
};

function initCanvas(canvas) {
    resizeCanvas();
    canvas.onmousemove = mouseMove;
    canvas.onmousedown = function (e) {
        if (e.shiftKey && undefined != hoveringOver) {
            model.disable(hoveringOver, tree);
            mouseDown = false;
            hoveringOver = undefined;
            dragging = undefined;
        } else {
            if (undefined != hoveringOver) {
                mouseDown = true;
                mouseDragOffsetVec = undefined;
            }
        }
    };
    canvas.onmouseup = function (e) {
        mouseDown = false;
        mouseDragOffsetVec = undefined;
        dragging = undefined;
    };
    canvasLeft = 0;
    canvasTop = 0;
    var e = canvas.parentNode;
    while (undefined != e) {
        if (undefined != e.offsetLeft && undefined != e.offsetTop) {
            canvasLeft += e.offsetLeft;
            canvasTop += e.offsetTop;
        }
        e = e.parentNode;
    }
    try {
        ctx = canvas.getContext("2d");
    } catch (e) {
    }
    if (!ctx) {
        alert("Could not initialise 2D canvas. Change browser?");
    }
}

function drawScene() {
    ctx.font = "" + fontSize + "px sans-serif";
    ctx.clearRect(0, 0, canvas.width -1, canvas.height -1);
    ctx.lineWidth = 1.0;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "black";
    ctx.strokeRect(0, 0, canvas.width -1, canvas.height -1);
    model.render(ctx);
};

var eta = 0.1;
var max_v = 100000;
function clamp(elem) {
    var x_vel_abs = Math.abs(elem.velocity[octtree.x]);
    var y_vel_abs = Math.abs(elem.velocity[octtree.y]);
    if (0 != x_vel_abs && eta > x_vel_abs) {
        elem.velocity[octtree.x] = 0;
    } else if (max_v < x_vel_abs) {
        elem.velocity[octtree.x] = max_v * (x_vel_abs / elem.velocity[octtree.x]);
    }
    if (0 != y_vel_abs && eta > y_vel_abs) {
        elem.velocity[octtree.y] = 0;
    } else if (max_v < y_vel_abs) {
        elem.velocity[octtree.y] = max_v * (y_vel_abs / elem.velocity[octtree.y]);
    }
    if (elem.next_pos[octtree.x] < 1) {
        elem.next_pos[octtree.x] = 1;
        elem.velocity[octtree.x] = 0;
    };
    if (elem.next_pos[octtree.y] < 1) {
        elem.next_pos[octtree.y] = 1;
        elem.velocity[octtree.y] = 0;
    }
    if (elem.next_pos[octtree.x] >= canvas.width) {
        elem.next_pos[octtree.x] = canvas.width - 1;
    };
    if (elem.next_pos[octtree.y] >= (canvas.height - 100)) {
        canvas.height += 100;
    }
};

var newton = new Newton();
var spring = new Spring();
spring.octtreeRadius = 500;
spring.equilibriumLength = 50;
spring.dampingFactor = 0.01;
spring.pull = false;
spring.push = true;

var rendering = true;
var lastTime = 0;

function enableRendering() {
    lastTime = 0;
    rendering = true;
}

function disableRendering() {
    rendering = false;
}

function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0 && rendering) {
        var elapsed = (timeNow - lastTime) / 10000;
        var e;
        for (var i in model.exchange) {
            e = model.exchange[i];
            if ((undefined == dragging || dragging != e) && ! e.disabled) {
                e.animate(elapsed);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        for (var i in model.queue) {
            e = model.queue[i];
            if ((undefined == dragging || dragging != e) && ! e.disabled) {
                e.animate(elapsed);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        tree.update();
    }
    lastTime = timeNow;
};

function tick() {
    drawScene();
    animate();
    requestAnimFrame(tick);
};

function visualisationStart() {
    canvas = document.getElementById("topology_canvas");
    initCanvas(canvas);
    update();
    tick();
}

function show(elemId, modelElem) {
    var hidden = document.getElementById(elemId);
    for (var i = 0; i < hidden.options.length; ++i) {
        var e = hidden.options[i];
        if (e.selected) {
            model.enable(modelElem[e.value], tree);
            hidden.remove(i);
            --i;
        }
    }
};

function showExchanges() {
    show("hidden_exchanges", model.exchange);
};

function showQueues() {
    show("hidden_queues", model.queue);
};

function disable_fun(elemId, postFun) {
    return function (model) {
        var optionElem = document.createElement('option');
        optionElem.text = '"' + this.name + '"';
        optionElem.value = this.name;
        document.getElementById(elemId).add(optionElem, null);
        var elemIdCopy = elemId;
        this.remove = function (tree) {
            document.getElementById(elemIdCopy).remove(optionElem);
            this.__proto__.remove(tree);
        };
        postFun(model);
    };
};

function enable_fun(postFun) {
    return function(model) {
        this.remove = this.__proto__.remove;
        postFun(model);
    };
};

Exchange.prototype.disable =
    disable_fun("hidden_exchanges", Exchange.prototype.disable);
Queue.prototype.disable =
    disable_fun("hidden_queues", Queue.prototype.disable);

Exchange.prototype.enable = enable_fun(Exchange.prototype.enable);
Queue.prototype.enable = enable_fun(Queue.prototype.enable);

</script>
<style type="text/css">
#side{
position: absolute;
top: 0;
bottom: 0;
left: 0;
width: 16%;
height: 100%;
overflow: auto;
}

#main{
position: fixed;
top: 0;
left: 16%;
right: 0;
bottom: 0;
overflow: auto;
margin: 0;
padding: 0;
border: 0;
}

.inner{
margin: 15px;
}

.hidden{
width: 100%;
}

.show_button{
float: right;
}

body{
margin: 0;
padding: 0;
border: 0;
overflow: hidden;
height: 100%;
max-height: 100%;
}

</style>
</head>
<body onload="visualisationStart();" onresize="resizeCanvas();" onfocus="enableRendering();" onblur="disableRendering();">
    <div id="side">
        <div class="inner">
            <p id="coords">coords</p>
            <hr style="clear:both;"/>

            <div>Exchanges
            <select id="hidden_exchanges" multiple="true" size="8" class="hidden"></select>
            <button class="show_button" onclick="showExchanges();">Show</button>
            </div>

            <hr style="clear:both;"/>

            <div class="hidden">Queues
            <select id="hidden_queues" multiple="true" size="8" class="hidden"></select>
            <button class="show_button" onclick="showQueues();">Show</button>
            </div>

            <hr style="clear:both;"/>

            <div class="hidden">Channels
            <select id="hidden_channels" multiple="true" size="8" class="hidden"></select>
            <button class="show_button" onclick="showChannels();">Show</button>
            </div>

            <hr style="clear:both;"/>

            <div class="hidden">Connections
            <select id="hidden_connections" multiple="true" size="8" class="hidden"></select>
            <button class="show_button" onclick="showConnections();">Show</button>
            </div>
        </div>
    </div>
    <div id="main" onscroll="canvasScroll();">
        <canvas id="topology_canvas"></canvas>
    </div>
</body>
</html>
