<!DOCTYPE html>
<html>

<head>
<title>RabbitMQ Topology Visualiser</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link href="../css/main.css" rel="stylesheet" type="text/css"/>

<script type="text/javascript" src="js/glMatrix-min.js"></script>
<script type="text/javascript" src="js/octtree.js"></script>
<script type="text/javascript" src="js/physics.js"></script>
<script type="text/javascript" src="js/model.js"></script>
<script type="text/javascript">

var updatePeriod = 1000; // 1 second
var updateTimer = undefined;

var client = new XMLHttpRequest();
client.onreadystatechange = updateReady;

var detailsClient = new XMLHttpRequest();
detailsClient.onreadystatechange = detailsUpdateReady;
var detailsInFlight = undefined;

var configuration = undefined;

var tree = octtree.create(0, 10000, 0, 1000000, -0.5, 2);
var model = new Model();
var mousePos = vec3.create();
var mouseDown = false;
var mouseDragOffsetVec = undefined;
var highlight = "#ffffc0";
var faded = "#b0b0b0";
var hoveringOver = undefined;
var dragging = undefined;
var selectedVhost = undefined;

function update() {
    if (undefined == selectedVhost) {
        client.open("GET", "/api/all");
    } else {
        client.open("GET", "/api/all/" + encodeURIComponent(selectedVhost));
    }
    client.send();
};

function updateReady() {
    if (client.readyState == 4 && client.status == 200) {
        updateTimer = setTimeout("update();", updatePeriod);
        configuration = JSON.parse(client.responseText);
        model.rebuild(tree, configuration);
    }
};

Channel.prototype.getDetails = getChannel;
Exchange.prototype.getDetails = getExchange;
Queue.prototype.getDetails = getQueue;

function getChannel() {
    detailsInFlight = this;
    detailsClient.abort();
    detailsClient.open("GET", "/api/channels/" + encodeURIComponent(this.name));
    detailsClient.send();
};

function getExchange() {
    detailsInFlight = this;
    detailsClient.abort();
    detailsClient.open("GET", "/api/exchanges/" + encodeURIComponent(this.vhost) +
                       "/" + encodeURIComponent(this.name));
    detailsClient.send();
};

function getQueue() {
    detailsInFlight = this;
    detailsClient.abort();
    detailsClient.open("GET", "/api/queues/" + encodeURIComponent(this.vhost) +
                       "/" + encodeURIComponent(this.name));
    detailsClient.send();
};

function detailsUpdateReady() {
    if (detailsClient.readyState == 4 &&
        detailsClient.status == 200 &&
        undefined != hoveringOver &&
        hoveringOver == detailsInFlight) {
        var details = JSON.parse(detailsClient.responseText);
        if (undefined != details.name &&
            details.name == detailsInFlight.name) {
            detailsInFlight.details = details;
        }
    }
};

function draggable(ctx) {
    var inPath = ctx.isPointInPath(mousePos[octtree.x], mousePos[octtree.y]);
    if ((inPath && undefined == hoveringOver) || dragging == this || hoveringOver == this) {
        ctx.fillStyle = highlight;
        ctx.fill();

        if (hoveringOver != this) {
            this.getDetails();
        }

        hoveringOver = this;
        if (mouseDown) {
            dragging = this;
            if (undefined == mouseDragOffsetVec) {
                mouseDragOffsetVec = vec3.create(this.pos);
                vec3.subtract(mouseDragOffsetVec, mousePos);
            }
            vec3.set(mousePos, this.next_pos);
            vec3.add(this.next_pos, mouseDragOffsetVec);
            this.velocity = vec3.create();
            clamp(this);
        } else if (!inPath) {
            if (undefined != hoveringOver) {
                hoveringOver.details = undefined;
            }
            dragging = undefined;
            hoveringOver = undefined;
            mouseDragOffsetVec = undefined;
        }
    } else {
        ctx.fillStyle = "white";
        ctx.fill();
    }
    if (undefined != hoveringOver && hoveringOver != this) {
        ctx.strokeStyle = faded;
    }
    ctx.stroke();
};
Channel.prototype.preStroke = draggable;
Exchange.prototype.preStroke = draggable;
Queue.prototype.preStroke = draggable;
Binding.prototype.preStroke = function(source, destination, ctx) {
    var drawBindingKeys = false;
    if (undefined == hoveringOver) {
        drawBindingKeys = ctx.isPointInPath(mousePos[octtree.x], mousePos[octtree.y]);
    } else {
        if (hoveringOver == source) {
            ctx.strokeStyle = "#0000a0";
            drawBindingKeys = true;
        } else if (hoveringOver == destination) {
            ctx.strokeStyle = "#00a000";
            drawBindingKeys = true;
        } else {
            ctx.strokeStyle = faded;
        }
    }
    ctx.stroke();

    if (drawBindingKeys) {
        var xMid = (source.xMax + destination.xMin) / 2;
        var yMid = source == destination ? source.pos[octtree.y]
            - this.loopOffset + 12
            : (source.pos[octtree.y] + destination.pos[octtree.y]) / 2;
        var bindingKey = "";
        for (var k in this.keys) {
            bindingKey += ", " + k;
        }
        bindingKey = bindingKey.slice(2);
        var dim = ctx.measureText(bindingKey);

        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(255, 255, 255, 0.67)";
        ctx.fillRect(xMid - dim.width/2, yMid - this.fontSize/2, dim.width, this.fontSize);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fillText(bindingKey, xMid, yMid);
    }
};

var requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
             window.setTimeout(callback, 1000/60);
           };
  })();

var ctx = undefined;
var fontSize = 12;
Exchange.prototype.fontSize = fontSize;
Queue.prototype.fontSize = fontSize;
Binding.prototype.fontSize = fontSize;
var canvas = undefined;
var canvasLeft = 0;
var canvasTop = 0;
var scrollLeft = 0;
var scrollTop = 0;
var clientWidth = 0;
var clientHeight = 0;

function mouseMove(e) {
    var x = e.pageX;
    var y = e.pageY;
    x = (x - canvasLeft) + scrollLeft;
    y = (y - canvasTop) + scrollTop;
    mousePos[octtree.x] = x;
    mousePos[octtree.y] = y;
};

function resizeCanvas() {
    if (undefined != canvas) {
        canvas.width = canvas.parentNode.offsetWidth;
        canvas.height = canvas.parentNode.offsetHeight;
        Channel.prototype.canvasResized(canvas);
        Exchange.prototype.canvasResized(canvas);
        Queue.prototype.canvasResized(canvas);
        clientWidth = canvas.width;
        clientHeight = canvas.height;
        var e = canvas.parentNode;
        while (undefined != e) {
            if (undefined != e.clientHeight && undefined != e.clientWidth &&
                e.clientHeight > 0 && e.clientWidth > 0) {
                clientHeight = Math.min(clientHeight, e.clientHeight);
                clientWidth = Math.min(clientWidth, e.clientWidth);
            }
            e = e.parentNode;
        }
    }
};

function canvasScroll() {
    scrollLeft = 0;
    scrollTop = 0;
    var e = canvas.parentNode;
    while (undefined != e) {
        if (undefined != e.scrollLeft && undefined != e.scrollTop) {
            scrollLeft += e.scrollLeft;
            scrollTop += e.scrollTop;
        }
        e = e.parentNode;
    }
};

function initCanvas(canvas) {
    resizeCanvas();
    canvas.onmousemove = mouseMove;
    canvas.onmousedown = function (e) {
        if (e.shiftKey && undefined != hoveringOver) {
            model.disable(hoveringOver, tree);
            mouseDown = false;
            hoveringOver = undefined;
            dragging = undefined;
        } else {
            if (undefined != hoveringOver) {
                mouseDown = true;
                mouseDragOffsetVec = undefined;
            }
        }
    };
    canvas.onmouseup = function (e) {
        mouseDown = false;
        mouseDragOffsetVec = undefined;
        dragging = undefined;
    };
    canvasLeft = 0;
    canvasTop = 0;
    var e = canvas.parentNode;
    while (undefined != e) {
        if (undefined != e.offsetLeft && undefined != e.offsetTop) {
            canvasLeft += e.offsetLeft;
            canvasTop += e.offsetTop;
        }
        e = e.parentNode;
    }
    try {
        ctx = canvas.getContext("2d");
    } catch (e) {
    }
    if (!ctx) {
        alert("Could not initialise 2D canvas. Change browser?");
    }
}

function drawScene() {
    ctx.font = "" + fontSize + "px sans-serif";
    ctx.clearRect(scrollLeft, scrollTop, clientWidth, clientHeight);
    ctx.lineWidth = 1.0;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "black";
    model.render(ctx);
};

var eta = 0.1;
var max_v = 100000;
function clamp(elem) {
    var x_vel_abs = Math.abs(elem.velocity[octtree.x]);
    var y_vel_abs = Math.abs(elem.velocity[octtree.y]);
    if (0 != x_vel_abs && eta > x_vel_abs) {
        elem.velocity[octtree.x] = 0;
    } else if (max_v < x_vel_abs) {
        elem.velocity[octtree.x] = max_v * (x_vel_abs / elem.velocity[octtree.x]);
    }
    if (0 != y_vel_abs && eta > y_vel_abs) {
        elem.velocity[octtree.y] = 0;
    } else if (max_v < y_vel_abs) {
        elem.velocity[octtree.y] = max_v * (y_vel_abs / elem.velocity[octtree.y]);
    }
    if (elem.next_pos[octtree.x] < 1) {
        elem.next_pos[octtree.x] = 1;
        elem.velocity[octtree.x] = 0;
    };
    if (elem.next_pos[octtree.y] < 1) {
        elem.next_pos[octtree.y] = 1;
        elem.velocity[octtree.y] = 0;
    }
    if (elem.next_pos[octtree.x] >= canvas.width) {
        elem.next_pos[octtree.x] = canvas.width - 1;
    };
    if (elem.next_pos[octtree.y] >= (canvas.height - 100)) {
        canvas.height += 100;
    }
};

var newton = new Newton();
var spring = new Spring();
spring.octtreeRadius = 500;
spring.equilibriumLength = 50;
spring.dampingFactor = 0.01;
spring.pull = false;
spring.push = true;

var rendering = true;
var lastTime = 0;

function enableRendering() {
    lastTime = 0;
    rendering = true;
}

function disableRendering() {
    rendering = false;
}

function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0 && rendering) {
        var elapsed = (timeNow - lastTime) / 10000;
        var e;
        for (var i in model.exchange) {
            e = model.exchange[i];
            if ((undefined == dragging || dragging != e) && ! e.disabled) {
                e.animate(elapsed);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        for (var i in model.channel) {
            e = model.channel[i];
            if ((undefined == dragging || dragging != e) && ! e.disabled) {
                e.animate(elapsed);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        for (var i in model.queue) {
            e = model.queue[i];
            if ((undefined == dragging || dragging != e) && ! e.disabled) {
                e.animate(elapsed);
                newton.update(elapsed, e);
                spring.update(elapsed, tree, e);
                clamp(e);
            }
        }
        tree.update();
    }
    lastTime = timeNow;
};

function tick() {
    drawScene();
    animate();
    requestAnimFrame(tick);
};

function visualisationStart() {
    canvas = document.getElementById("topology_canvas");
    initCanvas(canvas);
    update();
    tick();
}

function show(hiddenElemId, model, type) {
    if (model.rendering[type].enabled) {
        var hidden = document.getElementById(hiddenElemId);
        for (var i = 0; i < hidden.options.length; ++i) {
            var e = hidden.options[i];
            if (e.selected) {
                model.enable(model[type][e.value], tree);
                hidden.remove(i);
                --i;
            }
        }
    }
};

function showChannels() {
    show("hidden_channels", model, 'channel');
};

function showExchanges() {
    show("hidden_exchanges", model, 'exchange');
};

function showQueues() {
    show("hidden_queues", model, 'queue');
};

function disable_fun(hiddenElemId, type, postFun) {
    return function (model) {
        var optionElem = document.createElement('option');
        optionElem.text = '"' + this.name + '"';
        if (undefined != model.rendering[type].on_enable[this.name]) {
            optionElem.text += ' *';
        }
        optionElem.value = this.name;
        selectInsertAlphabetical(document.getElementById(hiddenElemId), optionElem);
        this.remove = remove_disabled_fun(hiddenElemId, this.remove);
        this.postFun = postFun;
        this.postFun(model);
    };
};

function selectInsertAlphabetical(selectElem, optionElem) {
    var preceding = null;
    for (var i = 0; i < selectElem.options.length; ++i) {
        if (optionElem.text < selectElem.options[i].text) {
            preceding = selectElem.options[i];
            break;
        }
    }
    selectElem.add(optionElem, preceding);
    return selectElem.options;
};

function frustumCull(xMin, yMin, width, height) {
    return ((yMin > (scrollTop + clientHeight)) ||
            ((yMin + height) < scrollTop) ||
            (xMin > (scrollLeft + clientWidth)) ||
            ((xMin + width) < scrollLeft));
};
Model.prototype.cull = frustumCull;

// Called when the item is removed and the item is disabled
function remove_disabled_fun(hiddenElemId, postFun) {
    return function (tree, model) {
        var hidden = document.getElementById(hiddenElemId);
        for (var i = 0; i < hidden.options.length; ++i) {
            if (hidden.options[i].value == this.name) {
                hidden.remove(i);
                break;
            }
        }
        model.enable(this, tree);
        this.postFun = postFun;
        this.postFun(tree, model);
    };
};

function enable_fun(type, postFun) {
    return function(model) {
        if (model.rendering[type].enabled) {
            delete model.rendering[type].on_enable[this.name];
        }
        this.remove = this.__proto__.remove;
        this.postFun = postFun;
        this.postFun(model);
    };
};

Channel.prototype.disable =
    disable_fun("hidden_channels", 'channel', Channel.prototype.disable);
Exchange.prototype.disable =
    disable_fun("hidden_exchanges", 'exchange', Exchange.prototype.disable);
Queue.prototype.disable =
    disable_fun("hidden_queues", 'queue', Queue.prototype.disable);

Channel.prototype.enable = enable_fun('channel', Channel.prototype.enable);
Exchange.prototype.enable = enable_fun('exchange', Exchange.prototype.enable);
Queue.prototype.enable = enable_fun('queue', Queue.prototype.enable);


function remove_fun(postFun, type) {
    return function (tree, model) {
        if (undefined != hoveringOver && this == hoveringOver) {
            hoveringOver = undefined;
            dragging = undefined;
        }
        delete model.rendering[type].on_enable[this.name];
        this.postFun = postFun;
        this.postFun(tree, model);
    };
};

Channel.prototype.remove = remove_fun(Channel.prototype.remove, 'channel');
Queue.prototype.remove = remove_fun(Queue.prototype.remove, 'queue');
Exchange.prototype.remove = remove_fun(Exchange.prototype.remove, 'exchange');

function toggleRendering(hiddenElemId, showButtonElemId, type) {
    model.rendering[type].enabled = !model.rendering[type].enabled;
    if (model.rendering[type].enabled) {
        var hidden = document.getElementById(hiddenElemId);
        for (var i = 0; i < hidden.options.length; ++i) {
            var e = hidden.options[i].value;
            if (undefined != model.rendering[type].on_enable[e]) {
                model.enable(model[type][e], tree);
                hidden.remove(i);
                --i;
            }
        }
        document.getElementById(showButtonElemId).disabled = false;
    } else {
        for (var i in model[type]) {
            if (! model[type][i].disabled) {
                model.rendering[type].on_enable[model[type][i].name] = true;
                model.disable(model[type][i], tree);
            }
        }
        document.getElementById(showButtonElemId).disabled = true;
    }
    return true;
}

Model.prototype.vhost_add = function (vhost) {
    var optionElem = document.createElement('option');
    optionElem.text = vhost.name;
    optionElem.value = vhost.name;
    var options =
        selectInsertAlphabetical(document.getElementById('vhosts'), optionElem);
    if (options.length == 1) {
        selectedVhost = options[0].value;
        options[0].selected = true;
    }
};

Model.prototype.vhost_remove = function (vhost) {
    var elem = document.getElementById('vhosts');
    for (var i = 0; i < elem.options.length; ++i) {
        if (elem.options[i].value == vhost.name) {
            elem.remove(i);
            break;
        }
    }
};

function vhostChanged() {
    var elem = document.getElementById('vhosts');
    for (var i = 0; i < elem.options.length; ++i) {
        if (elem.options[i].selected && selectedVhost != elem.options[i].value) {
            selectedVhost = elem.options[i].value;
            for (var e in ['channel', 'exchange', 'queue']) {
                for (var i in model[e]) {
                    model[e][i].remove(tree, model);
                }
            }
            break;
        }
    }
};

</script>
<style type="text/css">
#side{
position: absolute;
top: 0;
bottom: 0;
left: 0;
width: 16%;
height: 100%;
overflow: auto;
}

#main{
position: fixed;
top: 0;
left: 16%;
right: 0;
bottom: 0;
overflow: auto;
margin: 0;
padding: 0;
border: 0;
}

.inner{
margin: 10px;
}

.hidden{
width: 100%;
clear: both;
}

.show_button{
float: right;
}

body{
margin: 0;
padding: 0;
border: 0;
overflow: hidden;
height: 100%;
max-height: 100%;
}

</style>
</head>
<body onload="visualisationStart();" onresize="resizeCanvas();" onfocus="enableRendering();" onblur="disableRendering();">
    <div id="side">
        <div class="inner">
            <div><a href="../"><div id="logo"></div></a></div>

            <div>Vhost: <select id="vhosts" class="show_button" size="1" onchange="vhostChanged();"></select></div>

            <div class="hidden">Exchanges
                <div style="float: right;">
                    <input type="checkbox" value="Display" checked onclick="toggleRendering('hidden_exchanges', 'show_exchanges', 'exchange');"/>Display</div>
            <select id="hidden_exchanges" multiple="true" size="8" class="hidden"></select>
            <button id="show_exchanges" class="show_button" onclick="showExchanges();">Show</button>
            </div>

            <div class="hidden">Queues
                <div style="float: right;">
                    <input type="checkbox" value="Display" checked onclick="toggleRendering('hidden_queues', 'show_queues', 'queue');"/>Display</div>
            <select id="hidden_queues" multiple="true" size="8" class="hidden"></select>
            <button id="show_queues" class="show_button" onclick="showQueues();">Show</button>
            </div>

            <div class="hidden">Channels
                <div style="float: right;">
                    <input type="checkbox" value="Display" checked onclick="toggleRendering('hidden_channels', 'show_channels', 'channel');"/>Display</div>
            <select id="hidden_channels" multiple="true" size="8" class="hidden"></select>
            <button id="show_channels" class="show_button" onclick="showChannels();">Show</button>
            </div>

            <!-- <div class="hidden">Connections
                <div style="float: right;">
                    <input type="checkbox" value="Display" onclick="toggleConnections();"/>Display</div>
            <select id="hidden_connections" multiple="true" size="8" class="hidden"></select>
            <button class="show_button" onclick="showConnections();">Show</button>
            </div> -->
        </div>
    </div>
    <div id="main" onscroll="canvasScroll();">
        <canvas id="topology_canvas"></canvas>
    </div>
</body>
</html>
