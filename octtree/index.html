<html>

<head>
<title>RabbitMQ Topology Visualiser</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-min.js"></script>
<script type="text/javascript" src="octtree.js"></script>
<script type="text/javascript" src="physics.js"></script>
<script type="text/javascript">

var updatePeriod = 1000; // 1 second

var updateTimer = undefined;
var client = new XMLHttpRequest();
client.onreadystatechange = updateReady;

var configuration = undefined;
var vhost = "/";

var model = {};
model.exchanges = {};
model.bindings = {};
model.queues = {};
model.connections = {};
model.channels = {};

var tree = octtree.create(0, 10000, 0, 10000, -1, 1);
var mousePos = vec3.create();
var mouseDown = false;
var mouseDragOffsetVec = undefined;
var highlight = "#ffffc0";
var selected = undefined;

// all-configuration does not return default exchanges, nor transient things like channels and connections. Hence TODO: invent 'all' which really does return everything
function update() {
    client.open("GET", "/api/all-configuration");
    client.send();
};

function updateReady() {
    if (client.readyState == 4 && client.status == 200) {
        updateTimer = setTimeout("update();", updatePeriod);
        configuration = JSON.parse(client.responseText);
        rebuildModel();
    }
};

var exchange = { yMax: 100,
                 yIncr: 50,
                 xInit: 100,
                 xOffset: 100,
                 attributes: ['arguments', 'auto_delete', 'durable', 'internal', 'type']
               };
exchange.add = function(elem) {
    model.exchanges[elem.name] = elem;
    elem.pos = vec3.create();
    elem.pos[octtree.x] = exchange.xInit;
    elem.pos[octtree.y] = exchange.yMax;
    elem.pos[octtree.z] = 0;
    exchange.yMax += exchange.yIncr;
    var xInbound = 0;
    var xOutbound = 0;
    var xCount = 0;
    var incoming = model.bindings.destination["exchange"][elem.name];
    if (undefined != incoming && 0 < incoming.length) {
        var e;
        for (var i = 0; i < incoming.length; ++i) {
            e = model.exchanges[incoming[i].source];
            if (undefined != e) {
                xInbound += e.pos[octtree.x];
                xCount++;
            }
        };
        if (0 != xCount) {
            xInbound = xInbound / xCount;
        }
    }
    xCount = 0;
    var outgoing = model.bindings.source[elem.name];
    if (undefined != outgoing && 0 < outgoing.length) {
        var e;
        for (var i = 0; i < outgoing.length; ++i) {
            e = model.exchanges[outgoing[i].destination];
            if (undefined != e) {
                xOutbound += e.pos[octtree.x];
                xCount++;
            }
        };
        if (0 != xCount) {
            xOutbound = xOutbound / xCount;
        }
    }
    if (xInbound != 0) {
        elem.pos[octtree.x] = (xInbound + xOutbound) / 2;
    }
    elem.next_pos = vec3.create(elem.pos);
    elem.xMin = elem.pos[octtree.x];
    elem.xMax = elem.pos[octtree.x];
    elem.mass = 1;
    elem.velocity = vec3.create();
    tree.add(elem);
};
exchange.update = function(elem) {
    var e = model.exchanges[elem.name];
    var attr;
    for (var i = 0; i < exchange.attributes.length; ++i) {
        attr = exchange.attributes[i];
        e[attr] = elem[attr];
    }
};
exchange.remove = function(elem) {
    delete model.exchanges[elem.name];
};
exchange.render = function(elem, ctx) {
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "12px sans-serif";

    var dim = ctx.measureText(elem.name);

    ctx.lineWidth = 2.0;
    ctx.strokeStyle = "black";

    ctx.beginPath();
    ctx.arc(elem.pos[octtree.x] - (dim.width/2), elem.pos[octtree.y], 12, Math.PI/2, 3*Math.PI/2, false);
    ctx.lineTo(elem.pos[octtree.x] + (dim.width/2), elem.pos[octtree.y] - 12);

    ctx.arc(elem.pos[octtree.x] + (dim.width/2), elem.pos[octtree.y], 12, 3*Math.PI/2, Math.PI/2, false);
    ctx.closePath();
    draggable(elem, ctx);
    ctx.stroke();

    ctx.fillStyle = "black";
    ctx.fillText(elem.name, elem.pos[octtree.x], elem.pos[octtree.y]);
    
    elem.xMin = elem.pos[octtree.x] - (dim.width/2) - 12;
    elem.xMax = elem.pos[octtree.x] + (dim.width/2) + 12;
};

var queue = { yMax: 100,
              yIncr: 50,
              xInit: 400,
              attributes: ['arguments', 'auto_delete', 'durable']
            };
queue.add = function(elem) {
    model.queues[elem.name] = elem;
    elem.pos = vec3.create();
    elem.pos[octtree.x] = queue.xInit;
    elem.pos[octtree.y] = queue.yMax;
    elem.pos[octtree.z] = 0;
    queue.yMax += queue.yIncr;

    elem.next_pos = vec3.create(elem.pos);
    elem.xMin = elem.pos[octtree.x];
    elem.xMax = elem.pos[octtree.x];
    elem.mass = 1;
    elem.velocity = vec3.create();
    tree.add(elem);
};
queue.update = function(elem) {
    var q = model.queues[elem.name];
    var attr;
    for (var i = 0; i < queue.attributes.length; ++i) {
        attr = queue.attributes[i];
        q[attr] = elem[attr];
    }    
};
queue.remove = function(elem) {
    delete model.queues[elem.name];
};
queue.render = function(elem, ctx) {
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "12px sans-serif";
    var dim = ctx.measureText(elem.name);

    ctx.lineWidth = 2.0;
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(elem.pos[octtree.x] - (dim.width/2) - 12, elem.pos[octtree.y] - 12);
    ctx.lineTo(elem.pos[octtree.x] + (dim.width/2) + 12, elem.pos[octtree.y] - 12);
    ctx.lineTo(elem.pos[octtree.x] + (dim.width/2) + 12, elem.pos[octtree.y] + 12);
    ctx.lineTo(elem.pos[octtree.x] - (dim.width/2) - 12, elem.pos[octtree.y] + 12);
    ctx.closePath();

    draggable(elem, ctx);
    ctx.stroke();

    ctx.fillStyle = "black";
    ctx.fillText(elem.name, elem.pos[octtree.x], elem.pos[octtree.y]);

    elem.xMin = elem.pos[octtree.x] - (dim.width/2) - 12;
    elem.xMax = elem.pos[octtree.x] + (dim.width/2) + 12;
};

var binding = { offset: 100 };
binding.render = function(elem, ctx) {
    var source = model.exchanges[elem.source];
    var destination;
    if (elem.destination_type == "exchange") {
        destination = model.exchanges[elem.destination];
    } else {
        destination = model.queues[elem.destination];
    }
    var xMid = (source.xMax + destination.xMin) / 2;
    var xMid1 = xMid > (source.xMax + binding.offset) ? xMid : source.xMax + binding.offset;
    var xMid2 = xMid < (destination.xMin - binding.offset) ? xMid : destination.xMin - binding.offset; 
    ctx.lineWidth = 2.0;
    ctx.strokeStyle = "black";
    ctx.moveTo(source.xMax, source.pos[octtree.y]);
    
    ctx.bezierCurveTo(xMid1, source.pos[octtree.y], xMid2, destination.pos[octtree.y],
            destination.xMin, destination.pos[octtree.y]);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(destination.xMin, destination.pos[octtree.y]);
    ctx.lineTo(destination.xMin - 12, destination.pos[octtree.y] + 6);
    ctx.lineTo(destination.xMin - 12, destination.pos[octtree.y] - 6);
    ctx.closePath();
    ctx.fillStyle = "black";
    ctx.fill();
};

function draggable(elem, ctx) {
    var inPath = ctx.isPointInPath(mousePos[octtree.x], mousePos[octtree.y]); 
    if ((inPath && undefined == selected) || selected == elem) {
        ctx.fillStyle = highlight;
        ctx.fill();
        
        if (mouseDown) {
            selected = elem;
            if (undefined == mouseDragOffsetVec) {
                mouseDragOffsetVec = vec3.create(elem.pos);
                vec3.subtract(mouseDragOffsetVec, mousePos);
            }
            vec3.set(mousePos, elem.next_pos);
            vec3.add(elem.next_pos, mouseDragOffsetVec);
            elem.velocity = vec3.create();
        } else if (!inPath) {
            selected = undefined;
            mouseDragOffsetVec = undefined;
        }
    } else {
        ctx.fillStyle = "white";
        ctx.fill();
    }  
};

function rebuildModel() {
    model.bindings.source = {};
    model.bindings.destination = { "exchange": {}, "queue": {} };

    var elem;
    for (var i = 0; i < configuration.bindings.length; ++i) {
        elem = configuration.bindings[i];
        if (undefined == model.bindings.source[elem.source]) {
            model.bindings.source[elem.source] = new Array(elem);
        } else {
            model.bindings.source[elem.source].push(elem);
        }
        
        if (undefined == model.bindings.destination[elem.destination_type][elem.destination]) {
            model.bindings.destination[elem.destination_type][elem.destination] = new Array(elem);
        } else {
            model.bindings.destination[elem.destination_type][elem.destination].push(elem);
        }
    }
    
    var matched = {};
    for (var i = 0; i < configuration.exchanges.length; ++i) {
        elem = configuration.exchanges[i];
        if (elem.vhost == vhost) {
            if (undefined == model.exchanges[elem.name]) {
                exchange.add(elem);
            } else {
                exchange.update(elem);
            }
            matched[elem.name] = true;
        }
    }
    for (var i in model.exchanges) {
        if (undefined == matched[i]) {
            exchange.remove(model.exchanges[i]);
        }
    }

    matched = {};
    for (var i = 0; i < configuration.queues.length; ++i) {
        elem = configuration.queues[i];
        if (elem.vhost == vhost) {
            if (undefined == model.queues[elem.name]) {
                queue.add(elem);
            } else {
                queue.update(elem);
            }
            matched[elem.name] = true;
        }
    }
    for (var i in model.queues) {
        if (undefined == matched[i]) {
            queue.remove(model.queues[i]);
        }
    }

    matched = undefined;
};

window.requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
             window.setTimeout(callback, 1000/60);
           };
  })();

var ctx = undefined;
var canvas = undefined;

function mouseMove(e) {
    var x = 0;
    var y = 0;
    if (e.pageX || e.pageY) { 
        x = e.pageX;
        y = e.pageY;
    } else { 
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
    } 
    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;
    mousePos[octtree.x] = x;
    mousePos[octtree.y] = y;
};

function initCanvas(canvas) {
    canvas.width = window.document.body.offsetWidth;
    canvas.height = window.document.body.offsetHeight;
    canvas.onmousemove = mouseMove;
    canvas.onmousedown = function (e) { mouseDown = true; };
    canvas.onmouseup = function (e) { mouseDown = false; mouseDragOffsetVec = undefined; };
    try {
        ctx = canvas.getContext("2d");
    } catch (e) {
    }
    if (!ctx) {
        alert("Could not initialise 2D canvas. Change browser?");
    }
}

var lastTime = 0;

function drawScene() {
    ctx.lineWidth = 1.0;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    var e;
    for (var i in model.bindings.source) {
        var ary = model.bindings.source[i];
        for (var j = 0; j < ary.length; ++j) {
            e = ary[j];
            binding.render(e, ctx);
        }
    }
    for (var i in model.exchanges) {
        e = model.exchanges[i];
        exchange.render(e, ctx);
    }
    for (var i in model.queues) {
        e = model.queues[i];
        queue.render(e, ctx);
    }
};

gravity.octtreeRadius = 500;
gravity.bigG = 100;
gravity.repel = true;

function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
        var elapsed = (timeNow - lastTime) / 10000;
        var e;
        for (var i in model.exchanges) {
            e = model.exchanges[i];
            if (undefined == selected || selected != e) {
                newton.update(elapsed, e);
                gravity.update(elapsed, tree, e);
            }
        }
        for (var i in model.queues) {
            e = model.queues[i];
            if (undefined == selected || selected != e) {
                newton.update(elapsed, e);
                gravity.update(elapsed, tree, e);
            }
        }
        tree.update();
    }
    lastTime = timeNow;
};

function tick() {
    requestAnimFrame(tick);
    drawScene();
    animate();
};

function visualisationStart() {
    canvas = document.getElementById("topology-canvas");
    initCanvas(canvas);
    update();
    tick();
}

</script>
</head>
<body onload="visualisationStart();">
    <canvas id="topology-canvas"></canvas>
</body>
</html>